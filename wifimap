#!/usr/bin/python

"""
Sniffs on the WiFi network and generates a graph showing the communication
between the devices, including information about the announced SSIDs. Will
loop infinitely - kill the program with SIGINT in order to stop it
gracefully.

Example usage (the "timeout" kills wifimap after 5s):

    timeout --foreground -s INT 5s wifimap | dot -Tsvg > out.svg

Author: Jacek Wielemborek, licensed under WTFPL
"""

import subprocess
import sys
import time
import re
import threading
from StringIO import StringIO
from lxml import etree
from collections import defaultdict


def can_do_sudo():
    """Tells whether we can run sudo without being asked for password."""
    p = subprocess.Popen("SUDO_ASKPASS=/usr/bin/false sudo -A true",
                         shell=True)
    p.communicate()
    return p.returncode == 0


class ChannelHopper(threading.Thread):
    """A channel hopper thread. Switches the Wireless channel periodically."""

    def __init__(self, interval, iface):
        """
        Constructs a ChannelHopper instance.

        Args:

          interval - the time between channel switches
          iface - the interface to perform switching on
        """
        threading.Thread.__init__(self)
        self.running = True
        self.interval = interval
        self.iface = iface

    def get_frequency(self):
        """Returns the current frequency of the interface."""
        s = subprocess.check_output(["iwconfig", self.iface])
        return re.findall('Frequency:([^ ]+)', s)[0]

    def run(self):
        if not can_do_sudo():
            sys.stderr.write("Could not run passwordless sudo - channel hopper"
                             " skipped.\n")
            return
        else:
            sys.stderr.write("Channel hopper started.\n")
        start = self.get_frequency()
        channel = 1
        try:
            while self.running:
                x = subprocess.call(['sudo', '-A',
                                     'iwconfig', self.iface, 'channel',
                                     str(channel)], stderr=subprocess.PIPE)
                if x != 0:
                    channel = 0
                time.sleep(self.interval)
                channel += 1
        finally:
            subprocess.call(['sudo', '-A',
                             'iwconfig', self.iface, 'freq', start])
            end = self.get_frequency()
            if start != end:
                sys.stderr.write("WTF: Could not restore the "
                                 "frequency (%s vs %s)\n" % (start, end))
            else:
                sys.stderr.write("Channel hopper stopped.\n")


class Wifibacon(object):

    def __init__(self):
        self.seen = defaultdict(lambda: defaultdict(int))
        self.announces = defaultdict(list)

    def parse_packet(self, packet_str):
        """
        Parses a <packet></packet> XML string, returning information about the
        sender, receiver and the announced networks. If sender or receiver is
        not known, returns '?' in its place. If SSID is not announced, None
        is returned.
        """
        d = {}
        ssid = None
        for line in packet_str.split("\n"):
            if '"wlan.ra"' in line or '"wlan.ta"' in line \
                    or '"wlan.sa"' in line:
                field = etree.fromstring(line)
                if 'ff:ff:ff:ff:ff:ff' in field.get('showname'):
                    continue
                name = field.get('name')
                d[name] = field.get('showname').split(': ')[1]
                d[name] = d[name].replace(' ', '\\n')
            if '"wlan_mgt.ssid"' in line:
                field = etree.fromstring(line)
                if ssid is not None and field.get('show') != ssid:
                    sys.stderr.write("WTF: SSID: %s vs %s" % (repr(ssid),
                                     repr(field.get('show'))))
                ssid = field.get('show')
        if d.get('wlan.ta') != d.get('wlan.sa') \
                and d.get('wlan.ta') is not None \
                and d.get('wlan.sa') is not None:
            sys.stderr.write("WTF: ta=%s != sa=%s\n" %
                             (repr(d.get('wlan.ta')), repr(d.get('wlan.sa'))))
        to_mac = d.get('wlan.ra', '?') \
            if d.get('wlan.ra') != 'ffffffffffff' else '?'
        from_mac = d.get('wlan.ta', '?') or d.get('wlan.sa', '?')
        return from_mac, to_mac, ssid

    def handle_packet(self, from_mac, to_mac, ssid):
        """
        Handles information about noticing a given packet in order to prepare
        it for reporting.
        """
        self.seen[from_mac][to_mac] += 1
        if ssid:
            found = self.announces[from_mac]
            if len(found) != 0 and ssid not in found:
                sys.stderr.write('WTF: two ssids: %s, %s, %s\n' %
                                 (from_mac, ssid, found))
            if ssid not in found:
                self.announces[from_mac] += [ssid]

    def print_report(self, skip_broadcast=False):
        """
        Prints out a DOT file based on the gathered information.
        """
        print("strict digraph {")
        for k1 in self.seen:
            for k2 in self.seen[k1]:
                if skip_broadcast and (k1 == '?' or k2 == '?'):
                    continue
                if k1 in self.announces:
                    k1 += '\\nAnnounces: ' + ',\\n'.join(self.announces[k1])
                if k2 in self.announces:
                    k2 += '\\nAnnounces: ' + ',\\n'.join(self.announces[k2])
                print('"%s" -> "%s";' % (k1, k2))
        print("}")

    def read_from_file(self, infile, outfile=None):
        """
        Reads the output of tshark -T pdml. If outfile is specified,
        the information is also saved to the outfile.
        """
        packet = StringIO()
        while True:
            line = infile.readline()
            if line == '':
                break
            packet.write(line)
            if outfile:
                outfile.write(line)
            if '</packet>' in line:
                packet_str = packet.getvalue()
                packet_info = self.parse_packet(packet_str)
                self.handle_packet(*packet_info)
                packet = StringIO()


def main():

    from argparse import ArgumentParser, RawTextHelpFormatter
    parser = ArgumentParser(description=__doc__,
                            formatter_class=RawTextHelpFormatter)
    parser.add_argument('--infile')
    parser.add_argument('--outfile')
    parser.add_argument('--skip-broadcast', action='store_true')
    parser.add_argument('--no-channel-hop', action='store_true')
    parser.add_argument('--channel-hop-interval', type=float, default=5)
    parser.add_argument('--iface', default='wlp3s0')
    args = parser.parse_args()

    if args.outfile:
        outfile = open(args.outfile, "w")
    else:
        outfile = None

    p = None
    if args.infile:
        infile = open(args.infile)
    else:
        p = subprocess.Popen("tshark -i wlp3s0 -I -y IEEE802_11_RADIO -T pdml",
                             shell=True, stdout=subprocess.PIPE)
        infile = p.stdout

    w = Wifibacon()
    if not args.no_channel_hop:
        c = ChannelHopper(interval=args.channel_hop_interval, iface=args.iface)
        c.start()
    try:
        w.read_from_file(infile, outfile)
    except KeyboardInterrupt:
        pass
    finally:
        w.print_report(args.skip_broadcast)
        if not args.no_channel_hop:
            c.running = False
            c.join()

if __name__ == '__main__':
    main()
